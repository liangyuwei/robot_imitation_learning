%% Display the manually recorded calibration data (containing both electrical signals and the corresponding pre-defined angle values)

%% Prep
clear;
clc;

calib_file_name = '../motion-retargeting/glove_calib_data-20200827.h5'; %'../motion-retargeting/glove_calib_data-20200825.h5';


%% Calibration parameters generated by WiseGlove SDK
% left glove
l_elec_min = [583, 317, 2467, 360, 364, 2030, 346, ...
              462, 2441, 368, 412, 1998, 368, 342];
%[599, 301, 2516, 359, 335, 2019, 350, ...
%             432, 2443, 357, 413, 1917, 363, 347];
l_angle_min = zeros(1, 14); %l_angle_min(4) = 12;
l_elec_max = [1678, 1067, 2844, 2012, 2376, 2260, 1893, ...
              2272, 2603, 1779, 2260, 2427, 1570, 1768];
%[1606, 779, 2829, 1762, 2313, 2252, 1722, ...
%               2239, 2596, 1671, 2223, 2385, 1471, 1801];
l_angle_max = [45, 100, 53, 90, 120, 22, 90, ...
               120, 22, 90, 120, 35, 90, 120]; %l_angle_max(4) = 83;

% right glove
r_elec_min = [783, 323, 1936, 335, 327, 1686, 382, ...
              296, 1890, 376, 307, 1975, 430, 508];
% [819, 327, 1936, 344, 332, 1665, 396, ...
%               298, 1807, 391, 311, 1986, 449, 506];
r_angle_min = zeros(1, 14);
r_elec_max = [1529, 2528, 2739, 1355, 2009, 2015, 1619, ...
              1839, 2223, 1705, 2357, 2099, 1556, 2491];
% [1544, 2553, 2764, 1395, 1974, 2121, 1673, ...
%               1866, 2224, 1802, 2332, 2083, 1741, 2543];
r_angle_max = [45, 100, 53, 90, 120, 22, 90, ...
               120, 22, 90, 120, 35, 90, 120];
           
           
%% Test sequences data
l_test_seq_1_angle = h5read(calib_file_name, '/l_test_seq_1/glove_angle');
l_test_seq_1_elec = h5read(calib_file_name, '/l_test_seq_1/glove_elec');
r_test_seq_1_angle = h5read(calib_file_name, '/r_test_seq_1/glove_angle');
r_test_seq_1_elec = h5read(calib_file_name, '/r_test_seq_1/glove_elec');

figure;
plot(1:size(l_test_seq_1_elec, 2), l_test_seq_1_elec(2, :), 'b-'); hold on; grid on;
plot(1:size(l_test_seq_1_angle, 2), l_test_seq_1_angle(2, :), 'r-');
xlabel('frame'); ylabel('Electrical Signal');
title('Left Thumb S1 Electrical Signal');



%% Load zero state
l_all_0_angle = h5read(calib_file_name, '/l_all_0/glove_angle');
l_all_0_elec = h5read(calib_file_name, '/l_all_0/glove_elec');

r_all_0_angle = h5read(calib_file_name, '/r_all_0/glove_angle');
r_all_0_elec = h5read(calib_file_name, '/r_all_0/glove_elec');


%% Load left thumb data and display
% load angle and the corresponding electrical signal data
l_thumb_s1_90_angle = h5read(calib_file_name, '/l_thumb_s1_90/glove_angle'); 
l_thumb_s1_90_angle = l_thumb_s1_90_angle(2, :);
l_thumb_s1_90_elec = h5read(calib_file_name, '/l_thumb_s1_90/glove_elec');
l_thumb_s1_90_elec = l_thumb_s1_90_elec(2, :);

l_thumb_s1_120_angle = h5read(calib_file_name, '/l_thumb_s1_120/glove_angle'); 
l_thumb_s1_120_angle = l_thumb_s1_120_angle(2, :);
l_thumb_s1_120_elec = h5read(calib_file_name, '/l_thumb_s1_120/glove_elec');
l_thumb_s1_120_elec = l_thumb_s1_120_elec(2, :);

l_thumb_s1_150_angle = h5read(calib_file_name, '/l_thumb_s1_150/glove_angle'); 
l_thumb_s1_150_angle = l_thumb_s1_150_angle(2, :);
l_thumb_s1_150_elec = h5read(calib_file_name, '/l_thumb_s1_150/glove_elec');
l_thumb_s1_150_elec = l_thumb_s1_150_elec(2, :);

% post-processing, clamp the values to be inside range
% l_thumb_s1_90_elec_clamped = max(min(l_thumb_s1_90_elec, l_elec_max(2)), l_elec_min(2));
% l_thumb_s1_120_elec_clamped = max(min(l_thumb_s1_120_elec, l_elec_max(2)), l_elec_min(2));
% l_thumb_s1_150_elec_clamped = max(min(l_thumb_s1_150_elec, l_elec_max(2)), l_elec_min(2));

% diplay angle and the corresponding electrical signal   
%{
figure;
plot(1:size(l_thumb_s1_90_angle, 2), l_thumb_s1_90_angle(2, :), 'b-'); hold on; grid on;
plot(1:size(l_thumb_s1_90_elec, 2), l_thumb_s1_90_elec(2, :), 'r-'); hold on; grid on;
%}

% debug: try linear mapping using only two end-points as is applied by WiseGlove SDK   
%{
l_thumb_s1_90_angle_mapped_from_elec = linear_map(l_thumb_s1_90_elec, l_elec_min(2), l_elec_max(2), l_angle_min(2), l_angle_max(2));
figure;
plot(1:size(l_thumb_s1_90_angle, 2), l_thumb_s1_90_angle, 'b-.', 'LineWidth', 3); hold on; grid on;
plot(1:size(l_thumb_s1_90_angle_mapped_from_elec, 2), l_thumb_s1_90_angle_mapped_from_elec, 'r--', 'LineWidth', 3);
%}

% display the relation between electrical signal and 
l_thumb_s1_angle = 180 - [90, 120, 150, 180];
% l_thumb_s1_elec = [median(l_thumb_s1_90_elec_clamped), median(l_thumb_s1_120_elec_clamped), median(l_thumb_s1_150_elec_clamped)];

figure;
p1 = plot(l_thumb_s1_90_elec, l_thumb_s1_angle(1)*ones(1, size(l_thumb_s1_90_elec ,2)), 'r.'); hold on; grid on;
plot(l_thumb_s1_120_elec, l_thumb_s1_angle(2)*ones(1, size(l_thumb_s1_120_elec, 2)), 'r.');
plot(l_thumb_s1_150_elec, l_thumb_s1_angle(3)*ones(1, size(l_thumb_s1_150_elec, 2)), 'r.');
plot(l_all_0_elec(2, :), l_thumb_s1_angle(4)*ones(1, size(l_all_0_elec(2, :), 2)), 'r.');

p2 = plot(l_thumb_s1_90_elec, l_thumb_s1_90_angle, 'b.'); hold on; grid on;
plot(l_thumb_s1_120_elec, l_thumb_s1_120_angle, 'b.');
plot(l_thumb_s1_150_elec, l_thumb_s1_150_angle, 'b.');
plot(l_all_0_elec(2, :), l_all_0_angle(2, :), 'b.');
xlabel('Electrical signal'); ylabel('Joint angle / degree');
title('Left Thumb S1 Joint');
legend([p1(1), p2(1)], 'Ground Truth', 'Linearly Mapped Result', 'Location', 'NorthEastOutside');


%% Load right thumb data and display
% load angle and the corresponding electrical signal data
r_thumb_s1_90_angle = h5read(calib_file_name, '/r_thumb_s1_90/glove_angle'); 
r_thumb_s1_90_angle = r_thumb_s1_90_angle(2, :);
r_thumb_s1_90_elec = h5read(calib_file_name, '/r_thumb_s1_90/glove_elec');
r_thumb_s1_90_elec = r_thumb_s1_90_elec(2, :);

r_thumb_s1_120_angle = h5read(calib_file_name, '/r_thumb_s1_120/glove_angle'); 
r_thumb_s1_120_angle = r_thumb_s1_120_angle(2, :);
r_thumb_s1_120_elec = h5read(calib_file_name, '/r_thumb_s1_120/glove_elec');
r_thumb_s1_120_elec = r_thumb_s1_120_elec(2, :);

r_thumb_s1_150_angle = h5read(calib_file_name, '/r_thumb_s1_150/glove_angle'); 
r_thumb_s1_150_angle = r_thumb_s1_150_angle(2, :);
r_thumb_s1_150_elec = h5read(calib_file_name, '/r_thumb_s1_150/glove_elec');
r_thumb_s1_150_elec = r_thumb_s1_150_elec(2, :);

% post-processing, clamp the values to be inside range
% r_thumb_s1_90_elec_clamped = max(min(r_thumb_s1_90_elec, r_elec_max(2)), r_elec_min(2));
% r_thumb_s1_120_elec_clamped = max(min(r_thumb_s1_120_elec, r_elec_max(2)), r_elec_min(2));
% r_thumb_s1_150_elec_clamped = max(min(r_thumb_s1_150_elec, r_elec_max(2)), r_elec_min(2));

% diplay angle and the corresponding electrical signal   
%{
figure;
plot(1:size(r_thumb_s1_90_angle, 2), r_thumb_s1_90_angle(2, :), 'b-'); hold on; grid on;
plot(1:size(r_thumb_s1_90_elec, 2), r_thumb_s1_90_elec(2, :), 'r-'); hold on; grid on;
%}

% debug: try linear mapping using only two end-points as is applied by WiseGlove SDK   
%{
r_thumb_s1_90_angle_mapped_from_elec = linear_map(r_thumb_s1_90_elec, r_elec_min(2), r_elec_max(2), r_angle_min(2), r_angle_max(2));
figure;
plot(1:size(r_thumb_s1_90_angle, 2), r_thumb_s1_90_angle, 'b-.', 'LineWidth', 3); hold on; grid on;
plot(1:size(r_thumb_s1_90_angle_mapped_from_elec, 2), r_thumb_s1_90_angle_mapped_from_elec, 'r--', 'LineWidth', 3);
%}

% display the relation between electrical signal and 
r_thumb_s1_angle = 180 - [90, 120, 150, 180];
% r_thumb_s1_elec = [median(r_thumb_s1_90_elec_clamped), median(r_thumb_s1_120_elec_clamped), median(r_thumb_s1_150_elec_clamped)];

figure;
p1 = plot(r_thumb_s1_90_elec, r_thumb_s1_angle(1)*ones(1, size(r_thumb_s1_90_elec ,2)), 'r.'); hold on; grid on;
plot(r_thumb_s1_120_elec, r_thumb_s1_angle(2)*ones(1, size(r_thumb_s1_120_elec, 2)), 'r.');
plot(r_thumb_s1_150_elec, r_thumb_s1_angle(3)*ones(1, size(r_thumb_s1_150_elec, 2)), 'r.');
plot(r_all_0_elec(2, :), r_thumb_s1_angle(4)*ones(1, size(r_all_0_elec(2, :), 2)), 'r.');

p2 = plot(r_thumb_s1_90_elec, r_thumb_s1_90_angle, 'b.'); hold on; grid on;
plot(r_thumb_s1_120_elec, r_thumb_s1_120_angle, 'b.');
plot(r_thumb_s1_150_elec, r_thumb_s1_150_angle, 'b.');
plot(r_all_0_elec(2, :), r_all_0_angle(2, :), 'b.');
xlabel('Electrical signal'); ylabel('Joint angle / degree');
title('Right Thumb S1 Joint');
legend([p1(1), p2(1)], 'Ground Truth', 'Linearly Mapped Result', 'Location', 'NorthEastOutside');




%% Load right index finger and display
% load angle and the corresponding electrical signal data
r_index_s3_90_angle = h5read(calib_file_name, '/r_index_s3_90/glove_angle'); 
r_index_s3_90_angle = r_index_s3_90_angle(4, :);
r_index_s3_90_elec = h5read(calib_file_name, '/r_index_s3_90/glove_elec');
r_index_s3_90_elec = r_index_s3_90_elec(4, :);

r_index_s3_120_angle = h5read(calib_file_name, '/r_index_s3_120/glove_angle'); 
r_index_s3_120_angle = r_index_s3_120_angle(4, :);
r_index_s3_120_elec = h5read(calib_file_name, '/r_index_s3_120/glove_elec');
r_index_s3_120_elec = r_index_s3_120_elec(4, :);

r_index_s3_150_angle = h5read(calib_file_name, '/r_index_s3_150/glove_angle'); 
r_index_s3_150_angle = r_index_s3_150_angle(4, :);
r_index_s3_150_elec = h5read(calib_file_name, '/r_index_s3_150/glove_elec');
r_index_s3_150_elec = r_index_s3_150_elec(4, :);

% post-processing, clamp the values to be inside range
r_index_s3_90_elec_clamped = max(min(r_index_s3_90_elec, r_elec_max(4)), r_elec_min(4));
r_index_s3_120_elec_clamped = max(min(r_index_s3_120_elec, r_elec_max(4)), r_elec_min(4));
r_index_s3_150_elec_clamped = max(min(r_index_s3_150_elec, r_elec_max(4)), r_elec_min(4));

% diplay angle and the corresponding electrical signal   
%{
figure;
plot(1:size(r_index_s3_90_angle, 2), r_index_s3_90_angle(2, :), 'b-'); hold on; grid on;
plot(1:size(r_index_s3_90_elec, 2), r_index_s3_90_elec(2, :), 'r-'); hold on; grid on;
%}

% debug: try linear mapping using only two end-points as is applied by WiseGlove SDK   
%{
r_index_s3_90_angle_mapped_from_elec = linear_map(r_index_s3_90_elec, r_elec_min(2), r_elec_max(2), r_angle_min(2), r_angle_max(2));
figure;
plot(1:size(r_index_s3_90_angle, 2), r_index_s3_90_angle, 'b-.', 'LineWidth', 3); hold on; grid on;
plot(1:size(r_index_s3_90_angle_mapped_from_elec, 2), r_index_s3_90_angle_mapped_from_elec, 'r--', 'LineWidth', 3);
%}

% display the relation between electrical signal and 
r_index_s3_angle = 180 - [90, 120, 150, 180];
% r_index_s3_elec = [median(r_index_s3_90_elec_clamped), median(r_index_s3_120_elec_clamped), median(r_index_s3_150_elec_clamped)];

figure;
p1 = plot(r_index_s3_90_elec, r_index_s3_angle(1)*ones(1, size(r_index_s3_90_elec_clamped ,2)), 'r.'); hold on; grid on;
plot(r_index_s3_120_elec, r_index_s3_angle(2)*ones(1, size(r_index_s3_120_elec_clamped, 2)), 'r.');
plot(r_index_s3_150_elec, r_index_s3_angle(3)*ones(1, size(r_index_s3_150_elec_clamped, 2)), 'r.');
plot(r_all_0_elec(4, :), r_index_s3_angle(4)*ones(1, size(r_all_0_elec(4, :), 2)), 'r.');

p2 = plot(r_index_s3_90_elec, r_index_s3_90_angle, 'b.'); hold on; grid on;
plot(r_index_s3_120_elec, r_index_s3_120_angle, 'b.');
plot(r_index_s3_150_elec, r_index_s3_150_angle, 'b.');
plot(r_all_0_elec(4, :), r_all_0_angle(4, :), 'b.');
xlabel('Electrical signal'); ylabel('Joint angle / degree');
title('Right Index S3 Joint');
legend([p1(1), p2(1)], 'Ground Truth', 'Linearly Mapped Result', 'Location', 'NorthEastOutside');



% fit a curve to the data
% prepare data
x = [mean(r_index_s3_90_elec), ...
     mean(r_index_s3_120_elec), ...
     mean(r_index_s3_150_elec), ...
     mean(r_all_0_elec(4, :))];
y = [r_index_s3_angle(1), ...%*ones(1, size(r_index_s3_90_elec ,2)), ...
     r_index_s3_angle(2), ...%*ones(1, size(r_index_s3_120_elec ,2)), ...
     r_index_s3_angle(3), ...%*ones(1, size(r_index_s3_150_elec ,2)), ...
     r_index_s3_angle(4)]; ...%*ones(1, size(r_all_0_elec(4, :) ,2))];
x_linear = [r_index_s3_90_elec, ...
            r_index_s3_120_elec, ...
            r_index_s3_150_elec, ...
            r_all_0_elec(4, :)];
[x_linear, IA, IC] = unique(x_linear);
y_linear = [r_index_s3_90_angle, ...
            r_index_s3_120_angle, ...
            r_index_s3_150_angle, ...
            r_all_0_angle(4, :)];
y_linear = y_linear(IA); % remove duplicate points?        
x_fit = min([r_elec_min(4), x, x_linear]) : 10 : max([r_elec_max(4), x, x_linear]);
% perform linear interpolation for the linearly mapped data points 
% (no need to do extra fitting since the angle data is a linearly interpolated result. 
% All we need is to see its whole landscape.)
y_linear_fit = interp1(double(x_linear), y_linear, double(x_fit), 'linear');

% 1 - way 1: spline fitting
y_fit = spline(double(x), double(y), double(x_fit));
% y_linear_fit = spline(double(x_linear), double(y_linear), double(x_fit));

% 2 - way 2: polynomial fitting
n = 2; %1; % order of magnitude
[p, s] = polyfit(double(x), y, n);
y_fit = polyval(p, double(x_fit));

% plot the fitted result
figure;
p1 = plot(r_index_s3_90_elec, r_index_s3_angle(1)*ones(1, size(r_index_s3_90_elec ,2)), 'r.'); hold on; grid on;
plot(r_index_s3_120_elec, r_index_s3_angle(2)*ones(1, size(r_index_s3_120_elec, 2)), 'r.');
plot(r_index_s3_150_elec, r_index_s3_angle(3)*ones(1, size(r_index_s3_150_elec, 2)), 'r.');
plot(r_all_0_elec(4, :), r_index_s3_angle(4)*ones(1, size(r_all_0_elec(4, :), 2)), 'r.');

p2 = plot(r_index_s3_90_elec, r_index_s3_90_angle, 'b.'); hold on; grid on;
plot(r_index_s3_120_elec, r_index_s3_120_angle, 'b.');
plot(r_index_s3_150_elec, r_index_s3_150_angle, 'b.');
plot(r_all_0_elec(4, :), r_all_0_angle(4, :), 'b.');

p3 = plot(x_fit, y_fit, 'r-');
p4 = plot(x_fit, y_linear_fit, 'b-');

xlabel('Electrical signal', 'FontSize', 16); ylabel('Joint angle / degree', 'FontSize', 16);
title('Right Index S3 Joint');
legend([p1(1), p2(1), p3(1), p4(1)], 'Ground Truth', 'Linearly Mapped Result', ...
                                     'Fitted Curve - Ground Truth', 'Fitted Curve - Linearly Mapped Result', ...
                                     'Location', 'NorthEastOutside', 'FontSize', 14);

                                 
%% Load left index finger and display
% load angle and the corresponding electrical signal data
l_index_s3_90_angle = h5read(calib_file_name, '/l_index_s3_90/glove_angle'); 
l_index_s3_90_angle = l_index_s3_90_angle(4, :);
l_index_s3_90_elec = h5read(calib_file_name, '/l_index_s3_90/glove_elec');
l_index_s3_90_elec = l_index_s3_90_elec(4, :);

l_index_s3_120_angle = h5read(calib_file_name, '/l_index_s3_120/glove_angle'); 
l_index_s3_120_angle = l_index_s3_120_angle(4, :);
l_index_s3_120_elec = h5read(calib_file_name, '/l_index_s3_120/glove_elec');
l_index_s3_120_elec = l_index_s3_120_elec(4, :);

l_index_s3_150_angle = h5read(calib_file_name, '/l_index_s3_150/glove_angle'); 
l_index_s3_150_angle = l_index_s3_150_angle(4, :);
l_index_s3_150_elec = h5read(calib_file_name, '/l_index_s3_150/glove_elec');
l_index_s3_150_elec = l_index_s3_150_elec(4, :);

% post-processing, clamp the values to be inside range
l_index_s3_90_elec_clamped = max(min(l_index_s3_90_elec, l_elec_max(4)), l_elec_min(4));
l_index_s3_120_elec_clamped = max(min(l_index_s3_120_elec, l_elec_max(4)), l_elec_min(4));
l_index_s3_150_elec_clamped = max(min(l_index_s3_150_elec, l_elec_max(4)), l_elec_min(4));

% diplay angle and the corresponding electrical signal   
%{
figure;
plot(1:size(l_index_s3_90_angle, 2), l_index_s3_90_angle(2, :), 'b-'); hold on; grid on;
plot(1:size(l_index_s3_90_elec, 2), l_index_s3_90_elec(2, :), 'r-'); hold on; grid on;
%}

% debug: try linear mapping using only two end-points as is applied by WiseGlove SDK   
%{
l_index_s3_90_angle_mapped_from_elec = lineal_map(l_index_s3_90_elec, l_elec_min(2), l_elec_max(2), l_angle_min(2), l_angle_max(2));
figure;
plot(1:size(l_index_s3_90_angle, 2), l_index_s3_90_angle, 'b-.', 'LineWidth', 3); hold on; grid on;
plot(1:size(l_index_s3_90_angle_mapped_from_elec, 2), l_index_s3_90_angle_mapped_from_elec, 'r--', 'LineWidth', 3);
%}

% display the relation between electrical signal and 
l_index_s3_angle = 180 - [90, 120, 150, 180]; 
% l_index_s3_elec = [median(l_index_s3_90_elec_clamped), median(l_index_s3_120_elec_clamped), median(l_index_s3_150_elec_clamped)];



figure;
p1 = plot(l_index_s3_90_elec, l_index_s3_angle(1)*ones(1, size(l_index_s3_90_elec ,2)), 'r.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_angle(2)*ones(1, size(l_index_s3_120_elec, 2)), 'r.');
plot(l_index_s3_150_elec, l_index_s3_angle(3)*ones(1, size(l_index_s3_150_elec, 2)), 'r.');
plot(l_all_0_elec(4, :), l_index_s3_angle(4)*ones(1, size(l_all_0_elec(4, :), 2)), 'r.');

p2 = plot(l_index_s3_90_elec, l_index_s3_90_angle, 'b.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_120_angle, 'b.');
plot(l_index_s3_150_elec, l_index_s3_150_angle, 'b.');
plot(l_all_0_elec(4, :), l_all_0_angle(4, :), 'b.');
xlabel('Electrical signal'); ylabel('Joint angle / degree');
title('Left Index S3 Joint');
legend([p1(1), p2(1)], 'Ground Truth', 'Linearly Mapped Result', 'Location', 'NorthEastOutside');


% fit a curve to the data
% prepare data
x = [mean(l_index_s3_90_elec), ...
     mean(l_index_s3_120_elec), ...
     mean(l_index_s3_150_elec), ...
     mean(l_all_0_elec(4, :))];
y = [l_index_s3_angle(1), ... %*ones(1, size(l_index_s3_90_elec ,2)), ...
     l_index_s3_angle(2), ... %*ones(1, size(l_index_s3_120_elec ,2)), ...
     l_index_s3_angle(3), ... %*ones(1, size(l_index_s3_150_elec ,2)), ...
     l_index_s3_angle(4)]; %*ones(1, size(l_all_0_elec(4, :) ,2))];
x_linear = [l_index_s3_90_elec, ...
            l_index_s3_120_elec, ...
            l_index_s3_150_elec, ...
            l_all_0_elec(4, :)];
[x_linear, IA, IC] = unique(x_linear);
y_linear = [l_index_s3_90_angle, ...
            l_index_s3_120_angle, ...
            l_index_s3_150_angle, ...
            l_all_0_angle(4, :)];
y_linear = y_linear(IA); % remove duplicate points?        
x_fit = min([l_elec_min(4), x, x_linear]) : 10 : max([l_elec_max(4), x, x_linear]);
% perform linear interpolation for the linearly mapped data points 
% (no need to do extra fitting since the angle data is a linearly interpolated result. 
% All we need is to see its whole landscape.)
% y_linear_fit = interp1(double(x_linear), y_linear, double(x_fit), 'linear');

% 1 - way 1: spline fitting (doesn't allow duplicate values for the first input)
% y_fit = spline(double(x), double(y), double(x_fit));

% 2 - way 2: polynomial fitting (allows duplicate values for x)
n = 3; % order of magnitude
[p, s] = polyfit(double(x), y, n);
y_fit = polyval(p, double(x_fit));

% 3 - way 3: piecewise cubic Hermite interpolating polynomial, i.e. pchip
% y_fit = pchip(double(x), double(y), double(x_fit));

% 4 - interp1
% y_fit = interp1(double(x), double(y), double(x_fit), 'makima'); %'previous'); %'next'); %'nearest'); %'pchip'); %'cubic'); %'spline'); %'linear');

% plot the fitted result
figure;
p1 = plot(l_index_s3_90_elec, l_index_s3_angle(1)*ones(1, size(l_index_s3_90_elec ,2)), 'r.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_angle(2)*ones(1, size(l_index_s3_120_elec, 2)), 'r.');
plot(l_index_s3_150_elec, l_index_s3_angle(3)*ones(1, size(l_index_s3_150_elec, 2)), 'r.');
plot(l_all_0_elec(4, :), l_index_s3_angle(4)*ones(1, size(l_all_0_elec(4, :), 2)), 'r.');

p2 = plot(l_index_s3_90_elec, l_index_s3_90_angle, 'b.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_120_angle, 'b.');
plot(l_index_s3_150_elec, l_index_s3_150_angle, 'b.');
plot(l_all_0_elec(4, :), l_all_0_angle(4, :), 'b.');

p3 = plot(x_fit, y_fit, 'r-');
p4 = plot(x_fit, y_linear_fit, 'b-');

xlabel('Electrical signal', 'FontSize', 16); ylabel('Joint angle / degree', 'FontSize', 16);
title('Left Index S3 Joint');
legend([p1(1), p2(1), p3(1), p4(1)], 'Ground Truth', 'Linearly Mapped Result', ...
                                     'Fitted Curve - Ground Truth', 'Fitted Curve - Linearly Mapped Result', ...
                                     'Location', 'NorthEastOutside', 'FontSize', 14);


%% Calibrate index S3 joint data according to calibration data                               
% load test sequence data
l_test_seq_1_angle = h5read(calib_file_name, '/l_test_seq_1/glove_angle');
l_test_seq_1_elec = h5read(calib_file_name, '/l_test_seq_1/glove_elec');
r_test_seq_1_angle = h5read(calib_file_name, '/r_test_seq_1/glove_angle');
r_test_seq_1_elec = h5read(calib_file_name, '/r_test_seq_1/glove_elec');

% get raw index s3 joint data
l_test_seq_1_index_s3_angle = l_test_seq_1_angle(4, :);
l_test_seq_1_index_s3_elec = l_test_seq_1_elec(4, :);
% l_test_seq_1_index_s3_elec_clamped = max(min(l_test_seq_1_index_s3_elec, l_elec_max(4)), l_elec_min(4));

r_test_seq_1_index_s3_angle = r_test_seq_1_angle(4, :);
r_test_seq_1_index_s3_elec = r_test_seq_1_elec(4, :);
% r_test_seq_1_index_s3_elec_clamped = max(min(r_test_seq_1_index_s3_elec, r_elec_max(4)), r_elec_min(4));

% get calibration data
x_l_index_s3 = [mean(l_index_s3_90_elec), ...
     mean(l_index_s3_120_elec), ...
     mean(l_index_s3_150_elec), ...
     mean(l_all_0_elec(4, :))];
y_l_index_s3 = [l_index_s3_angle(1), ...%*ones(1, size(l_index_s3_90_elec ,2)), ...
     l_index_s3_angle(2), ...%*ones(1, size(l_index_s3_120_elec ,2)), ...
     l_index_s3_angle(3), ...%*ones(1, size(l_index_s3_150_elec ,2)), ...
     l_index_s3_angle(4)]; %*ones(1, size(l_all_0_elec(4, :) ,2))];
x_r_index_s3 = [mean(r_index_s3_90_elec), ...
     mean(r_index_s3_120_elec), ...
     mean(r_index_s3_150_elec), ...
     mean(r_all_0_elec(4, :))];
y_r_index_s3 = [r_index_s3_angle(1), ...%*ones(1, size(r_index_s3_90_elec ,2)), ...
     r_index_s3_angle(2), ...%*ones(1, size(r_index_s3_120_elec ,2)), ...
     r_index_s3_angle(3), ...%*ones(1, size(r_index_s3_150_elec ,2)), ...
     r_index_s3_angle(4)];%*ones(1, size(r_all_0_elec(4, :) ,2))];

% fit polynomials for calibration
n = 2;
[p_l, s_l] = polyfit(double(x_l_index_s3), double(y_l_index_s3), n);
[p_r, s_r] = polyfit(double(x_r_index_s3), double(y_r_index_s3), n);

% calibrate the raw data
l_test_seq_1_index_s3_angle_calib = polyval(p_l, double(l_test_seq_1_index_s3_elec));
% r_test_seq_1_index_s3_angle_calib = polyval(p_r, double(r_test_seq_1_index_s3_elec));
% l_test_seq_1_index_s3_angle_calib = interp1(double(x_l_index_s3), double(y_l_index_s3), double(max(min(l_test_seq_1_index_s3_elec, max(x_l_index_s3)), min(x_l_index_s3))), 'linear');
% r_test_seq_1_index_s3_angle_calib = interp1(double(x_r_index_s3), double(y_r_index_s3), double(max(min(r_test_seq_1_index_s3_elec, max(x_r_index_s3)), min(x_r_index_s3))), 'linear');
% l_test_seq_1_index_s3_angle_calib = spline(double(x_l_index_s3), double(y_l_index_s3), double(l_test_seq_1_index_s3_elec));
r_test_seq_1_index_s3_angle_calib = spline(double(x_r_index_s3), double(y_r_index_s3), double(r_test_seq_1_index_s3_elec));


% display the results for comparison
num_points = size(l_test_seq_1_index_s3_elec, 2);
% raw
% l_test_seq_1_index_s3_angle_mapped = linear_map(l_test_seq_1_index_s3_elec_clamped, l_elec_min(4), l_elec_max(4), l_angle_min(4), l_angle_max(4));
% r_test_seq_1_index_s3_angle_mapped = linear_map(r_test_seq_1_index_s3_elec_clamped, r_elec_min(4), r_elec_max(4), r_angle_min(4), r_angle_max(4));
figure;
p1 = plot(1:num_points, l_test_seq_1_index_s3_angle, 'b-'); hold on; grid on;
p2 = plot(1:num_points, r_test_seq_1_index_s3_angle, 'r-'); 
xlabel('Points'); ylabel('Angle');
title('Linearly Mapped Left and Right Index S3 Joint');
legend([p1(1), p2(1)], 'Left Index S3', 'Right Index S3', 'Location', 'NorthEastOutside');
% calibrated
figure;
p1 = plot(1:num_points, l_test_seq_1_index_s3_angle_calib, 'b-'); hold on; grid on;
p2 = plot(1:num_points, r_test_seq_1_index_s3_angle_calib, 'r-'); 
xlabel('Points'); ylabel('Angle');
title('Calibrated Left and Right Index S3 Joint');
legend([p1(1), p2(1)], 'Left Index S3', 'Right Index S3', 'Location', 'NorthEastOutside');



