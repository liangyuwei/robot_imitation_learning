%% Display the manually recorded calibration data (containing both electrical signals and the corresponding pre-defined angle values)

%% Prep
clear;
clc;

calib_file_name = 'glove-calib-2020-11-10.h5'; %glove_calib_data-20200827.h5'; %'../motion-retargeting/glove_calib_data-20200825.h5';

% remember to update the calib.txt from rosserial_wiseglove
calib_text_l = 'calib_l-20201110.txt';
calib_text_r = 'calib_r-20201110.txt';

% read an example motion for calibration
test_seq_name = 'test_lr_index_bend_simul'; %'test_finger_1'; %'gun_new'; %'test_finger_2'; %'test_finger_1';
test_seq_angle = h5read(calib_file_name, ['/', test_seq_name, '/glove_angle']);
test_seq_elec = h5read(calib_file_name, ['/', test_seq_name, '/glove_elec']);
test_seq_angle_calib = test_seq_angle; % for storing the calibrated data


%% Calibration parameters generated by WiseGlove SDK
% read max and min elec from Wiseglove calibration texts
% l 
[~, ~, l_elec_min, ~, l_elec_max, ~, ~] = textread(calib_text_l, '%s%s%n%s%n%s%n');
l_elec_min = l_elec_min(2:end);
l_elec_max = l_elec_max(2:end);
% r
[~, ~, r_elec_min, ~, r_elec_max, ~, ~] = textread(calib_text_r, '%s%s%n%s%n%s%n');
r_elec_min = r_elec_min(2:end);
r_elec_max = r_elec_max(2:end);

% set max and min angle for human hand joints
% l
l_angle_min = zeros(1, 15); 
l_angle_max = [45, 100, 53, 90, 120, 22, 90, ...
               120, 22, 90, 120, 35, 90, 120, ...
               90];
% r
r_angle_min = zeros(1, 15); 
r_angle_max = [45, 100, 53, 90, 120, 22, 90, ...
               120, 22, 90, 120, 35, 90, 120, ...
               90];


%% Load zero state (flat palm, with four fingers fully expanded)
% Naming convention: lr_all_close
lr_all_0_angle = h5read(calib_file_name, '/lr_all_close/glove_angle');
lr_all_0_elec = h5read(calib_file_name, '/lr_all_close/glove_elec');

l_all_0_angle = lr_all_0_angle(1:15, :); % linearly mapped; for comparison
l_all_0_elec = lr_all_0_elec(1:15, :);
r_all_0_angle = lr_all_0_angle(16:end, :);
r_all_0_elec = lr_all_0_elec(16:end, :);


%% Calibrate all flexion/extension joints of three fingers
% Naming convention: {lr}_{index/middle/ring/little}_{s3,s4,s6,s7,s9,s10,s12,s13}_{90/120/150}
%prep
finger_name = {'index', 'middle', 'ring', 'little'};
joint_id = [[3, 4]; ...
            [6, 7]; ...
            [9, 10]; ...
            [12, 13]];  % starts from 0
d_right = 15; % offset from left joints to right corresponding joints

% 1 - iterate over flexion/extension for four fingers
for fid = 1 : length(finger_name)
    for jid = 1 : size(joint_id, 2)
        %% get ID
        l_id = joint_id(fid, jid) + 1; % starts from 1, used to access array in MATLAB
        r_id = l_id + d_right;
        
        %% read calib data
        % l
        l_90_angle = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_90/glove_angle']);
        l_90_angle = l_90_angle(l_id, :);
        l_90_elec = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_90/glove_elec']);
        l_90_elec = l_90_elec(l_id, :);
        
        l_120_angle = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_120/glove_angle']);                
        l_120_angle = l_120_angle(l_id, :);
        l_120_elec = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_120/glove_elec']);
        l_120_elec = l_120_elec(l_id, :);
        
        l_150_angle = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_150/glove_angle']);
        l_150_angle = l_150_angle(l_id, :);
        l_150_elec = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_150/glove_elec']);
        l_150_elec = l_150_elec(l_id, :);
        
        % r
        r_90_angle = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_90/glove_angle']);
        r_90_angle = r_90_angle(r_id, :);
        r_90_elec = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_90/glove_elec']);
        r_90_elec = r_90_elec(r_id, :);
        
        r_120_angle = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_120/glove_angle']);                
        r_120_angle = r_120_angle(r_id, :);
        r_120_elec = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_120/glove_elec']);
        r_120_elec = r_120_elec(r_id, :);
        
        r_150_angle = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_150/glove_angle']);
        r_150_angle = r_150_angle(r_id, :);
        r_150_elec = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_150/glove_elec']);
        r_150_elec = r_150_elec(r_id, :);
        
        % set paired data 
        % 1 - use mean data only
%         l_elec = [mean(l_90_elec), ...
%             mean(l_120_elec), ...
%             mean(l_150_elec), ...
%             mean(l_all_0_elec(l_id, :))];
%         l_angle = 180 - [90, 120, 150, 180]; 
%         r_elec = [mean(r_90_elec), ...
%             mean(r_120_elec), ...
%             mean(r_150_elec), ...
%             mean(r_all_0_elec(l_id, :))];
%         r_angle = 180 - [90, 120, 150, 180]; 
        % 2 - use all data
        l_elec = [l_90_elec, l_120_elec, l_150_elec, l_all_0_elec(l_id, :)];
        l_angle = [90 * ones(size(l_90_elec)), ...
                   60 * ones(size(l_120_elec)), ...
                   30 * ones(size(l_150_elec)), ...
                   0 * ones(size(l_all_0_elec(l_id, :)))];
        r_elec = [r_90_elec, r_120_elec, r_150_elec, r_all_0_elec(l_id, :)];
        r_angle = [90 * ones(size(r_90_elec)), ...
                   60 * ones(size(r_120_elec)), ...
                   30 * ones(size(r_150_elec)), ...
                   0 * ones(size(r_all_0_elec(l_id, :)))];       
        
        % get data for calibration 
        l_calib_angle = test_seq_angle(l_id, :);
        l_calib_elec = test_seq_elec(l_id, :);
        r_calib_angle = test_seq_angle(r_id, :);
        r_calib_elec = test_seq_elec(r_id, :);        
        
        % pre-processing, clampping on elec data
%         l_elec = max(min(l_elec, l_elec_max(l_id)), l_elec_min(l_id));
%         r_elec = max(min(r_elec, r_elec_max(l_id)), r_elec_min(l_id));
        
        
        % call helper function to calibrate test data
        finger_flag = ['S', num2str(joint_id(fid, jid))];
        [new_angle_calib_l, new_angle_calib_r] = calib_finger(l_angle, l_elec, l_calib_angle, l_calib_elec, ...
                                                              r_angle, r_elec, r_calib_angle, r_calib_elec, ...
                                                              l_angle_min(l_id), l_angle_max(l_id), ...
                                                              r_angle_min(l_id), r_angle_max(l_id), ..., 
                                                              false, finger_flag);
        
        % post-processing, clampping on angle data
%         new_angle_calib_l = max(min(new_angle_calib_l, l_angle_max(l_id)), l_angle_min(l_id));
%         new_angle_calib_r = max(min(new_angle_calib_r, r_angle_max(l_id)), r_angle_min(l_id)); % use l_id for r_elec_min too
                                                          
        % store the calibrated data
        test_seq_angle_calib(l_id, :) = new_angle_calib_l;
        test_seq_angle_calib(r_id, :) = new_angle_calib_r;
        
    end 
end

                                 
%% Load left index finger and display
%{
% load angle and the corresponding electrical signal data
l_index_s3_90_angle = h5read(calib_file_name, '/l_index_s3_90/glove_angle'); 
l_index_s3_90_angle = l_index_s3_90_angle(4, :);
l_index_s3_90_elec = h5read(calib_file_name, '/l_index_s3_90/glove_elec');
l_index_s3_90_elec = l_index_s3_90_elec(4, :);

l_index_s3_120_angle = h5read(calib_file_name, '/l_index_s3_120/glove_angle'); 
l_index_s3_120_angle = l_index_s3_120_angle(4, :);
l_index_s3_120_elec = h5read(calib_file_name, '/l_index_s3_120/glove_elec');
l_index_s3_120_elec = l_index_s3_120_elec(4, :);

l_index_s3_150_angle = h5read(calib_file_name, '/l_index_s3_150/glove_angle'); 
l_index_s3_150_angle = l_index_s3_150_angle(4, :);
l_index_s3_150_elec = h5read(calib_file_name, '/l_index_s3_150/glove_elec');
l_index_s3_150_elec = l_index_s3_150_elec(4, :);

% post-processing, clamp the values to be inside range
l_index_s3_90_elec_clamped = max(min(l_index_s3_90_elec, l_elec_max(4)), l_elec_min(4));
l_index_s3_120_elec_clamped = max(min(l_index_s3_120_elec, l_elec_max(4)), l_elec_min(4));
l_index_s3_150_elec_clamped = max(min(l_index_s3_150_elec, l_elec_max(4)), l_elec_min(4));

% diplay angle and the corresponding electrical signal   
%{
figure;
plot(1:size(l_index_s3_90_angle, 2), l_index_s3_90_angle(2, :), 'b-'); hold on; grid on;
plot(1:size(l_index_s3_90_elec, 2), l_index_s3_90_elec(2, :), 'r-'); hold on; grid on;
%}

% debug: try linear mapping using only two end-points as is applied by WiseGlove SDK   
%{
l_index_s3_90_angle_mapped_from_elec = lineal_map(l_index_s3_90_elec, l_elec_min(2), l_elec_max(2), l_angle_min(2), l_angle_max(2));
figure;
plot(1:size(l_index_s3_90_angle, 2), l_index_s3_90_angle, 'b-.', 'LineWidth', 3); hold on; grid on;
plot(1:size(l_index_s3_90_angle_mapped_from_elec, 2), l_index_s3_90_angle_mapped_from_elec, 'r--', 'LineWidth', 3);
%}

% display the relation between electrical signal and 
l_index_s3_angle = 180 - [90, 120, 150, 180]; 
% l_index_s3_elec = [median(l_index_s3_90_elec_clamped), median(l_index_s3_120_elec_clamped), median(l_index_s3_150_elec_clamped)];



figure;
p1 = plot(l_index_s3_90_elec, l_index_s3_angle(1)*ones(1, size(l_index_s3_90_elec ,2)), 'r.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_angle(2)*ones(1, size(l_index_s3_120_elec, 2)), 'r.');
plot(l_index_s3_150_elec, l_index_s3_angle(3)*ones(1, size(l_index_s3_150_elec, 2)), 'r.');
plot(l_all_0_elec(4, :), l_index_s3_angle(4)*ones(1, size(l_all_0_elec(4, :), 2)), 'r.');

p2 = plot(l_index_s3_90_elec, l_index_s3_90_angle, 'b.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_120_angle, 'b.');
plot(l_index_s3_150_elec, l_index_s3_150_angle, 'b.');
plot(l_all_0_elec(4, :), l_all_0_angle(4, :), 'b.');
xlabel('Electrical signal'); ylabel('Joint angle / degree');
title('Left Index S3 Joint');
legend([p1(1), p2(1)], 'Ground Truth', 'Linearly Mapped Result', 'Location', 'NorthEastOutside');


% fit a curve to the data
% prepare data
x = [mean(l_index_s3_90_elec), ...
     mean(l_index_s3_120_elec), ...
     mean(l_index_s3_150_elec), ...
     mean(l_all_0_elec(4, :))];
y = [l_index_s3_angle(1), ... %*ones(1, size(l_index_s3_90_elec ,2)), ...
     l_index_s3_angle(2), ... %*ones(1, size(l_index_s3_120_elec ,2)), ...
     l_index_s3_angle(3), ... %*ones(1, size(l_index_s3_150_elec ,2)), ...
     l_index_s3_angle(4)]; %*ones(1, size(l_all_0_elec(4, :) ,2))];
x_linear = [l_index_s3_90_elec, ...
            l_index_s3_120_elec, ...
            l_index_s3_150_elec, ...
            l_all_0_elec(4, :)];
[x_linear, IA, IC] = unique(x_linear);
y_linear = [l_index_s3_90_angle, ...
            l_index_s3_120_angle, ...
            l_index_s3_150_angle, ...
            l_all_0_angle(4, :)];
y_linear = y_linear(IA); % remove duplicate points?        
x_fit = min([l_elec_min(4), x, x_linear]) : 10 : max([l_elec_max(4), x, x_linear]);
% perform linear interpolation for the linearly mapped data points 
% (no need to do extra fitting since the angle data is a linearly interpolated result. 
% All we need is to see its whole landscape.)
y_linear_fit = interp1(double(x_linear), y_linear, double(x_fit), 'linear');

% 1 - way 1: spline fitting (doesn't allow duplicate values for the first input)
% y_fit = spline(double(x), double(y), double(x_fit));

% 2 - way 2: polynomial fitting (allows duplicate values for x)
n = 1; % order of magnitude
[p, s] = polyfit(double(x), y, n);
y_fit = polyval(p, double(x_fit));


% 3 - way 3: least mean squares regression (elec = a * angle + b)
% try least mean squares regression
y_elec = [l_index_s3_90_elec, l_index_s3_120_elec, l_index_s3_150_elec, l_all_0_elec(4, :)];
x_angle = [l_index_s3_angle(1)*ones(size(l_index_s3_90_elec)), ...
           l_index_s3_angle(2)*ones(size(l_index_s3_120_elec)), ...
           l_index_s3_angle(3)*ones(size(l_index_s3_150_elec)), ...
           l_index_s3_angle(4)*ones(size(l_all_0_elec(4, :)))];
[pp, ss] = polyfit(x_angle, double(y_elec), 1); % elec = a * angle + b ==> angle = (elec - b) / a
a = pp(1); b = pp(2);
pp(1) = 1 / a; pp(2) = -b / a;
y_fit2 = polyval(pp, double(x_fit));


% 3 - way 3: piecewise cubic Hermite interpolating polynomial, i.e. pchip
% y_fit = pchip(double(x), double(y), double(x_fit));

% 4 - interp1
% y_fit = interp1(double(x), double(y), double(x_fit), 'makima'); %'previous'); %'next'); %'nearest'); %'pchip'); %'cubic'); %'spline'); %'linear');

% plot the fitted result
figure;
p1 = plot(l_index_s3_90_elec, l_index_s3_angle(1)*ones(1, size(l_index_s3_90_elec ,2)), 'r.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_angle(2)*ones(1, size(l_index_s3_120_elec, 2)), 'r.');
plot(l_index_s3_150_elec, l_index_s3_angle(3)*ones(1, size(l_index_s3_150_elec, 2)), 'r.');
plot(l_all_0_elec(4, :), l_index_s3_angle(4)*ones(1, size(l_all_0_elec(4, :), 2)), 'r.');

p2 = plot(l_index_s3_90_elec, l_index_s3_90_angle, 'b.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_120_angle, 'b.');
plot(l_index_s3_150_elec, l_index_s3_150_angle, 'b.');
plot(l_all_0_elec(4, :), l_all_0_angle(4, :), 'b.');

p3 = plot(x_fit, y_fit, 'r-');
p4 = plot(x_fit, y_linear_fit, 'b-');
p5 = plot(x_fit, y_fit2, 'g-');

xlabel('Electrical signal', 'FontSize', 16); ylabel('Joint angle / degree', 'FontSize', 16);
title('Left Index S3 Joint');
legend([p1(1), p2(1), p3(1), p4(1), p5(1)], 'Ground Truth', 'Linearly Mapped Result', ...
                                     'Fitted Curve - Ground Truth', 'Fitted Curve - Linearly Mapped Result', 'Reversely linearly mapped', ...
                                     'Location', 'NorthEastOutside', 'FontSize', 14);



% 2 - iterate over abduction/adduction for all five fingers
% S2 (thumb-index)

% S5 (index-middle)

% S8 (middle-ring)

% S11 (ring-little)



% 3 - thumb angles
% S14
thumb_s14_0_elec = h5read(calib_file_name, ['/lr_thumb_s14_0/glove_elec']);
l_thumb_s14_0_elec = thumb_s14_0_elec(15, :);
r_thumb_s14_0_elec = thumb_s14_0_elec(15+d_right, :);

thumb_s14_90_elec = h5read(calib_file_name, ['/lr_thumb_s14_90/glove_elec']);
l_thumb_s14_90_elec = thumb_s14_90_elec(15, :);
r_thumb_s14_90_elec = thumb_s14_90_elec(15+d_right, :);

% prepare data to aid calibration
l_elec = [l_thumb_s14_0_elec, l_thumb_s14_90_elec];
l_angle = [0 * ones(size(l_thumb_s14_0_elec)), 90 * ones(size(l_thumb_s14_90_elec))];
r_elec = [r_thumb_s14_0_elec, r_thumb_s14_90_elec];
r_angle = [0 * ones(size(r_thumb_s14_0_elec)), 90 * ones(size(r_thumb_s14_90_elec))];

% get data for calibration 
l_calib_angle = test_seq_angle(15, :);
l_calib_elec = test_seq_elec(15, :);
r_calib_angle = test_seq_angle(15+d_right, :);
r_calib_elec = test_seq_elec(15+d_right, :);  

% calibrate
finger_flag = 'S14';
[new_angle_calib_l, new_angle_calib_r] = calib_finger(l_angle, l_elec, l_calib_angle, l_calib_elec, ...
                                                      r_angle, r_elec, r_calib_angle, r_calib_elec, ...
                                                      l_angle_min(15), l_angle_max(15), ...
                                                      r_angle_min(15), r_angle_max(15), ..., 
                                                      false, finger_flag);

% save the calibrated result
test_seq_angle_calib(15, :) = new_angle_calib_l;
test_seq_angle_calib(15+d_right, :) = new_angle_calib_r;


% S0


% S1


%}

%% save the calibrated results
%
h5create(calib_file_name, ['/', test_seq_name, '_calibrated'], size(test_seq_angle_calib));
h5write(calib_file_name, ['/', test_seq_name, '_calibrated'], test_seq_angle_calib);
%}

