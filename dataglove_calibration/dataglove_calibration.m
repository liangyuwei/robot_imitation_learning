%% Display the manually recorded calibration data (containing both electrical signals and the corresponding pre-defined angle values)

%% Prep
clear;
clc;

calib_file_name = 'glove-calib-2020-11-02.h5'; %glove_calib_data-20200827.h5'; %'../motion-retargeting/glove_calib_data-20200825.h5';

% remember to update the calib.txt from rosserial_wiseglove
calib_text_l = 'calib_l-20201102.txt';
calib_text_r = 'calib_r-20201102.txt';


%% Calibration parameters generated by WiseGlove SDK
% read from Wiseglove calibration texts
% l 
[~, ~, l_elec_min, ~, l_elec_max, ~, ~] = textread(calib_text_l, '%s%s%n%s%n%s%n');
l_elec_min = l_elec_min(2:end);
l_elec_max = l_elec_max(2:end);
% r
[~, ~, r_elec_min, ~, r_elec_max, ~, ~] = textread(calib_text_r, '%s%s%n%s%n%s%n');
r_elec_min = r_elec_min(2:end);
r_elec_max = r_elec_max(2:end);


% left glove
%l_elec_min = [583, 317, 2467, 360, 364, 2030, 346, ...
%              462, 2441, 368, 412, 1998, 368, 342];
%[599, 301, 2516, 359, 335, 2019, 350, ...
%             432, 2443, 357, 413, 1917, 363, 347];
l_angle_min = zeros(1, 15); %zeros(1, 14); %l_angle_min(4) = 12;
%l_elec_max = [1678, 1067, 2844, 2012, 2376, 2260, 1893, ...
%              2272, 2603, 1779, 2260, 2427, 1570, 1768];
%[1606, 779, 2829, 1762, 2313, 2252, 1722, ...
%               2239, 2596, 1671, 2223, 2385, 1471, 1801];
l_angle_max = [45, 100, 53, 90, 120, 22, 90, ...
               120, 22, 90, 120, 35, 90, 120, ...
               90];
               %58]; %l_angle_max(4) = 83;

% right glove
%r_elec_min = [783, 323, 1936, 335, 327, 1686, 382, ...
%              296, 1890, 376, 307, 1975, 430, 508];
% [819, 327, 1936, 344, 332, 1665, 396, ...
%               298, 1807, 391, 311, 1986, 449, 506];
r_angle_min = zeros(1, 15); %zeros(1, 14);
%r_elec_max = [1529, 2528, 2739, 1355, 2009, 2015, 1619, ...
%              1839, 2223, 1705, 2357, 2099, 1556, 2491];
% [1544, 2553, 2764, 1395, 1974, 2121, 1673, ...
%               1866, 2224, 1802, 2332, 2083, 1741, 2543];
r_angle_max = [45, 100, 53, 90, 120, 22, 90, ...
               120, 22, 90, 120, 35, 90, 120, ...
               90];
               %58];
           
           
%% Test sequences data
%{

% l_test_seq_1_angle = h5read(calib_file_name, '/l_test_seq_1/glove_angle');
% l_test_seq_1_elec = h5read(calib_file_name, '/l_test_seq_1/glove_elec');
% r_test_seq_1_angle = h5read(calib_file_name, '/r_test_seq_1/glove_angle');
% r_test_seq_1_elec = h5read(calib_file_name, '/r_test_seq_1/glove_elec');

test_seq_1_angle = h5read(calib_file_name, '/test_finger_1/glove_angle');
test_seq_1_elec = h5read(calib_file_name, '/test_finger_1/glove_elec');
l_test_seq_1_angle = test_seq_1_angle(1:15, :);
l_test_seq_1_elec = test_seq_1_angle(1:15, :);
r_test_seq_1_angle = test_seq_1_angle(16:end, :);
r_test_seq_1_elec = test_seq_1_angle(16:end, :);


figure;
plot(1:size(l_test_seq_1_elec, 2), l_test_seq_1_elec(2, :), 'b-'); hold on; grid on;
plot(1:size(l_test_seq_1_angle, 2), l_test_seq_1_angle(2, :), 'r-');
xlabel('frame'); ylabel('Electrical Signal');
title('Left Thumb S1 Electrical Signal');

figure;
plot(1:size(r_test_seq_1_elec, 2), r_test_seq_1_elec(2, :), 'b-'); hold on; grid on;
plot(1:size(r_test_seq_1_angle, 2), r_test_seq_1_angle(2, :), 'r-');
xlabel('frame'); ylabel('Electrical Signal');
title('Right Thumb S1 Electrical Signal');
%}



%% Load zero state (flat palm, with four fingers fully expanded)
lr_all_0_angle = h5read(calib_file_name, '/lr_open/glove_angle');
lr_all_0_elec = h5read(calib_file_name, '/lr_open/glove_elec');

l_all_0_angle = lr_all_0_angle(1:15, :);
l_all_0_elec = lr_all_0_elec(1:15, :);
r_all_0_angle = lr_all_0_angle(16:end, :);
r_all_0_elec = lr_all_0_elec(16:end, :);

% l_all_0_angle = h5read(calib_file_name, '/l_all_0/glove_angle');
% l_all_0_elec = h5read(calib_file_name, '/l_all_0/glove_elec');
% r_all_0_angle = h5read(calib_file_name, '/r_all_0/glove_angle');
% r_all_0_elec = h5read(calib_file_name, '/r_all_0/glove_elec');



%% Load left thumb data and display
% load angle and the corresponding electrical signal data
%{
l_thumb_s1_90_angle = h5read(calib_file_name, '/l_thumb_s1_90/glove_angle'); 
l_thumb_s1_90_angle = l_thumb_s1_90_angle(2, :);
l_thumb_s1_90_elec = h5read(calib_file_name, '/l_thumb_s1_90/glove_elec');
l_thumb_s1_90_elec = l_thumb_s1_90_elec(2, :);

l_thumb_s1_120_angle = h5read(calib_file_name, '/l_thumb_s1_120/glove_angle'); 
l_thumb_s1_120_angle = l_thumb_s1_120_angle(2, :);
l_thumb_s1_120_elec = h5read(calib_file_name, '/l_thumb_s1_120/glove_elec');
l_thumb_s1_120_elec = l_thumb_s1_120_elec(2, :);

l_thumb_s1_150_angle = h5read(calib_file_name, '/l_thumb_s1_150/glove_angle'); 
l_thumb_s1_150_angle = l_thumb_s1_150_angle(2, :);
l_thumb_s1_150_elec = h5read(calib_file_name, '/l_thumb_s1_150/glove_elec');
l_thumb_s1_150_elec = l_thumb_s1_150_elec(2, :);
%}

% post-processing, clamp the values to be inside range
% l_thumb_s1_90_elec_clamped = max(min(l_thumb_s1_90_elec, l_elec_max(2)), l_elec_min(2));
% l_thumb_s1_120_elec_clamped = max(min(l_thumb_s1_120_elec, l_elec_max(2)), l_elec_min(2));
% l_thumb_s1_150_elec_clamped = max(min(l_thumb_s1_150_elec, l_elec_max(2)), l_elec_min(2));

% diplay angle and the corresponding electrical signal   
%{
figure;
plot(1:size(l_thumb_s1_90_angle, 2), l_thumb_s1_90_angle(2, :), 'b-'); hold on; grid on;
plot(1:size(l_thumb_s1_90_elec, 2), l_thumb_s1_90_elec(2, :), 'r-'); hold on; grid on;
%}

% debug: try linear mapping using only two end-points as is applied by WiseGlove SDK   
%{
l_thumb_s1_90_angle_mapped_from_elec = linear_map(l_thumb_s1_90_elec, l_elec_min(2), l_elec_max(2), l_angle_min(2), l_angle_max(2));
figure;
plot(1:size(l_thumb_s1_90_angle, 2), l_thumb_s1_90_angle, 'b-.', 'LineWidth', 3); hold on; grid on;
plot(1:size(l_thumb_s1_90_angle_mapped_from_elec, 2), l_thumb_s1_90_angle_mapped_from_elec, 'r--', 'LineWidth', 3);
%}

% display the relation between electrical signal and 
%{
l_thumb_s1_angle = 180 - [90, 120, 150, 180];
% l_thumb_s1_elec = [median(l_thumb_s1_90_elec_clamped), median(l_thumb_s1_120_elec_clamped), median(l_thumb_s1_150_elec_clamped)];

figure;
p1 = plot(l_thumb_s1_90_elec, l_thumb_s1_angle(1)*ones(1, size(l_thumb_s1_90_elec ,2)), 'r.'); hold on; grid on;
plot(l_thumb_s1_120_elec, l_thumb_s1_angle(2)*ones(1, size(l_thumb_s1_120_elec, 2)), 'r.');
plot(l_thumb_s1_150_elec, l_thumb_s1_angle(3)*ones(1, size(l_thumb_s1_150_elec, 2)), 'r.');
plot(l_all_0_elec(2, :), l_thumb_s1_angle(4)*ones(1, size(l_all_0_elec(2, :), 2)), 'r.');

p2 = plot(l_thumb_s1_90_elec, l_thumb_s1_90_angle, 'b.'); hold on; grid on;
plot(l_thumb_s1_120_elec, l_thumb_s1_120_angle, 'b.');
plot(l_thumb_s1_150_elec, l_thumb_s1_150_angle, 'b.');
plot(l_all_0_elec(2, :), l_all_0_angle(2, :), 'b.');
xlabel('Electrical signal'); ylabel('Joint angle / degree');
title('Left Thumb S1 Joint');
legend([p1(1), p2(1)], 'Ground Truth', 'Linearly Mapped Result', 'Location', 'NorthEastOutside');
%}


%% Load right thumb data and display
% load angle and the corresponding electrical signal data
%{
r_thumb_s1_90_angle = h5read(calib_file_name, '/r_thumb_s1_90/glove_angle'); 
r_thumb_s1_90_angle = r_thumb_s1_90_angle(2, :);
r_thumb_s1_90_elec = h5read(calib_file_name, '/r_thumb_s1_90/glove_elec');
r_thumb_s1_90_elec = r_thumb_s1_90_elec(2, :);

r_thumb_s1_120_angle = h5read(calib_file_name, '/r_thumb_s1_120/glove_angle'); 
r_thumb_s1_120_angle = r_thumb_s1_120_angle(2, :);
r_thumb_s1_120_elec = h5read(calib_file_name, '/r_thumb_s1_120/glove_elec');
r_thumb_s1_120_elec = r_thumb_s1_120_elec(2, :);

r_thumb_s1_150_angle = h5read(calib_file_name, '/r_thumb_s1_150/glove_angle'); 
r_thumb_s1_150_angle = r_thumb_s1_150_angle(2, :);
r_thumb_s1_150_elec = h5read(calib_file_name, '/r_thumb_s1_150/glove_elec');
r_thumb_s1_150_elec = r_thumb_s1_150_elec(2, :);
%}

% post-processing, clamp the values to be inside range
% r_thumb_s1_90_elec_clamped = max(min(r_thumb_s1_90_elec, r_elec_max(2)), r_elec_min(2));
% r_thumb_s1_120_elec_clamped = max(min(r_thumb_s1_120_elec, r_elec_max(2)), r_elec_min(2));
% r_thumb_s1_150_elec_clamped = max(min(r_thumb_s1_150_elec, r_elec_max(2)), r_elec_min(2));

% diplay angle and the corresponding electrical signal   
%{
figure;
plot(1:size(r_thumb_s1_90_angle, 2), r_thumb_s1_90_angle(2, :), 'b-'); hold on; grid on;
plot(1:size(r_thumb_s1_90_elec, 2), r_thumb_s1_90_elec(2, :), 'r-'); hold on; grid on;
%}

% debug: try linear mapping using only two end-points as is applied by WiseGlove SDK   
%{
r_thumb_s1_90_angle_mapped_from_elec = linear_map(r_thumb_s1_90_elec, r_elec_min(2), r_elec_max(2), r_angle_min(2), r_angle_max(2));
figure;
plot(1:size(r_thumb_s1_90_angle, 2), r_thumb_s1_90_angle, 'b-.', 'LineWidth', 3); hold on; grid on;
plot(1:size(r_thumb_s1_90_angle_mapped_from_elec, 2), r_thumb_s1_90_angle_mapped_from_elec, 'r--', 'LineWidth', 3);
%}

% display the relation between electrical signal and 
%{
r_thumb_s1_angle = 180 - [90, 120, 150, 180];
% r_thumb_s1_elec = [median(r_thumb_s1_90_elec_clamped), median(r_thumb_s1_120_elec_clamped), median(r_thumb_s1_150_elec_clamped)];

figure;
p1 = plot(r_thumb_s1_90_elec, r_thumb_s1_angle(1)*ones(1, size(r_thumb_s1_90_elec ,2)), 'r.'); hold on; grid on;
plot(r_thumb_s1_120_elec, r_thumb_s1_angle(2)*ones(1, size(r_thumb_s1_120_elec, 2)), 'r.');
plot(r_thumb_s1_150_elec, r_thumb_s1_angle(3)*ones(1, size(r_thumb_s1_150_elec, 2)), 'r.');
plot(r_all_0_elec(2, :), r_thumb_s1_angle(4)*ones(1, size(r_all_0_elec(2, :), 2)), 'r.');

p2 = plot(r_thumb_s1_90_elec, r_thumb_s1_90_angle, 'b.'); hold on; grid on;
plot(r_thumb_s1_120_elec, r_thumb_s1_120_angle, 'b.');
plot(r_thumb_s1_150_elec, r_thumb_s1_150_angle, 'b.');
plot(r_all_0_elec(2, :), r_all_0_angle(2, :), 'b.');
xlabel('Electrical signal'); ylabel('Joint angle / degree');
title('Right Thumb S1 Joint');
legend([p1(1), p2(1)], 'Ground Truth', 'Linearly Mapped Result', 'Location', 'NorthEastOutside');
%}


%% Load right index finger and display
% load angle and the corresponding electrical signal data
r_index_s3_90_angle = h5read(calib_file_name, '/r_index_s3_90/glove_angle'); 
r_index_s3_90_angle = r_index_s3_90_angle(4+15, :);
r_index_s3_90_elec = h5read(calib_file_name, '/r_index_s3_90/glove_elec');
r_index_s3_90_elec = r_index_s3_90_elec(4+15, :);

r_index_s3_120_angle = h5read(calib_file_name, '/r_index_s3_120/glove_angle'); 
r_index_s3_120_angle = r_index_s3_120_angle(4+15, :);
r_index_s3_120_elec = h5read(calib_file_name, '/r_index_s3_120/glove_elec');
r_index_s3_120_elec = r_index_s3_120_elec(4+15, :);

r_index_s3_150_angle = h5read(calib_file_name, '/r_index_s3_150/glove_angle'); 
r_index_s3_150_angle = r_index_s3_150_angle(4+15, :);
r_index_s3_150_elec = h5read(calib_file_name, '/r_index_s3_150/glove_elec');
r_index_s3_150_elec = r_index_s3_150_elec(4+15, :);

% post-processing, clamp the values to be inside range
r_index_s3_90_elec_clamped = max(min(r_index_s3_90_elec, r_elec_max(4)), r_elec_min(4));
r_index_s3_120_elec_clamped = max(min(r_index_s3_120_elec, r_elec_max(4)), r_elec_min(4));
r_index_s3_150_elec_clamped = max(min(r_index_s3_150_elec, r_elec_max(4)), r_elec_min(4));

% diplay angle and the corresponding electrical signal   
%{
figure;
plot(1:size(r_index_s3_90_angle, 2), r_index_s3_90_angle(2, :), 'b-'); hold on; grid on;
plot(1:size(r_index_s3_90_elec, 2), r_index_s3_90_elec(2, :), 'r-'); hold on; grid on;
%}

% debug: try linear mapping using only two end-points as is applied by WiseGlove SDK   
%{
r_index_s3_90_angle_mapped_from_elec = linear_map(r_index_s3_90_elec, r_elec_min(2), r_elec_max(2), r_angle_min(2), r_angle_max(2));
figure;
plot(1:size(r_index_s3_90_angle, 2), r_index_s3_90_angle, 'b-.', 'LineWidth', 3); hold on; grid on;
plot(1:size(r_index_s3_90_angle_mapped_from_elec, 2), r_index_s3_90_angle_mapped_from_elec, 'r--', 'LineWidth', 3);
%}

% display the relation between electrical signal and 
r_index_s3_angle = 180 - [90, 120, 150, 180];
% r_index_s3_elec = [median(r_index_s3_90_elec_clamped), median(r_index_s3_120_elec_clamped), median(r_index_s3_150_elec_clamped)];

% plot all sample data points
figure;
p1 = plot(r_index_s3_90_elec, r_index_s3_angle(1)*ones(1, size(r_index_s3_90_elec_clamped ,2)), 'r.'); hold on; grid on;
plot(r_index_s3_120_elec, r_index_s3_angle(2)*ones(1, size(r_index_s3_120_elec_clamped, 2)), 'r.');
plot(r_index_s3_150_elec, r_index_s3_angle(3)*ones(1, size(r_index_s3_150_elec_clamped, 2)), 'r.');
plot(r_all_0_elec(4, :), r_index_s3_angle(4)*ones(1, size(r_all_0_elec(4, :), 2)), 'r.');

p2 = plot(r_index_s3_90_elec, r_index_s3_90_angle, 'b.'); hold on; grid on;
plot(r_index_s3_120_elec, r_index_s3_120_angle, 'b.');
plot(r_index_s3_150_elec, r_index_s3_150_angle, 'b.');
plot(r_all_0_elec(4, :), r_all_0_angle(4, :), 'b.');
xlabel('Electrical signal'); ylabel('Joint angle / degree');
title('Right Index S3 Joint');
legend([p1(1), p2(1)], 'Ground Truth', 'Linearly Mapped Result', 'Location', 'NorthEastOutside');


% plot all sample data points for each sample of the same joint angle
figure;
subplot(2, 2, 1);
plot(r_index_s3_90_elec, 'b.'); hold on; grid on;
plot(1:size(r_index_s3_90_elec, 2), mean(r_index_s3_90_elec)*ones(size(r_index_s3_90_elec)), 'r-');
plot(1:size(r_index_s3_90_elec, 2), double(median(r_index_s3_90_elec))*ones(size(r_index_s3_90_elec)), 'g--');
title('Right index S3 electrical signal under 90 deg');
subplot(2, 2, 2);
plot(r_index_s3_120_elec, 'b.'); hold on; grid on;
plot(1:size(r_index_s3_120_elec, 2), mean(r_index_s3_120_elec)*ones(size(r_index_s3_120_elec)), 'r-');
plot(1:size(r_index_s3_120_elec, 2), double(median(r_index_s3_120_elec))*ones(size(r_index_s3_120_elec)), 'g--');
title('Right index S3 electrical signal under 60 deg');
subplot(2, 2, 3);
plot(r_index_s3_150_elec, 'b.'); hold on; grid on;
plot(1:size(r_index_s3_150_elec, 2), mean(r_index_s3_150_elec)*ones(size(r_index_s3_150_elec)), 'r-');
plot(1:size(r_index_s3_150_elec, 2), double(median(r_index_s3_150_elec))*ones(size(r_index_s3_150_elec)), 'g--');
title('Right index S3 electrical signal under 30 deg');
subplot(2, 2, 4);
plot(r_all_0_elec(4, :), 'b.'); hold on; grid on;
plot(1:size(r_all_0_elec(4, :), 2), mean(r_all_0_elec(4, :))*ones(size(r_all_0_elec(4, :))), 'r-');
plot(1:size(r_all_0_elec(4, :), 2), double(median(r_all_0_elec(4, :)))*ones(size(r_all_0_elec(4, :))), 'g--');
title('Right index S3 electrical signal under 0 deg');



% fit a curve to the data
% prepare data
x = [mean(r_index_s3_90_elec), ...
     mean(r_index_s3_120_elec), ...
     mean(r_index_s3_150_elec), ...
     mean(r_all_0_elec(4, :))];
y = [r_index_s3_angle(1), ...%*ones(1, size(r_index_s3_90_elec ,2)), ...
     r_index_s3_angle(2), ...%*ones(1, size(r_index_s3_120_elec ,2)), ...
     r_index_s3_angle(3), ...%*ones(1, size(r_index_s3_150_elec ,2)), ...
     r_index_s3_angle(4)]; ...%*ones(1, size(r_all_0_elec(4, :) ,2))];
x_linear = [r_index_s3_90_elec, ...
            r_index_s3_120_elec, ...
            r_index_s3_150_elec, ...
            r_all_0_elec(4, :)];
[x_linear, IA, IC] = unique(x_linear);
y_linear = [r_index_s3_90_angle, ...
            r_index_s3_120_angle, ...
            r_index_s3_150_angle, ...
            r_all_0_angle(4, :)];
y_linear = y_linear(IA); % remove duplicate points?        
x_fit = min([r_elec_min(4), x, x_linear]) : 10 : max([r_elec_max(4), x, x_linear]);
% perform linear interpolation for the linearly mapped data points 
% (no need to do extra fitting since the angle data is a linearly interpolated result. 
% All we need is to see its whole landscape.)
y_linear_fit = interp1(double(x_linear), y_linear, double(x_fit), 'linear');

% 1 - way 1: spline fitting
% y_fit = spline(double(x), double(y), double(x_fit));
% y_linear_fit = spline(double(x_linear), double(y_linear), double(x_fit));

% 2 - way 2: polynomial fitting
n = 2; %4;%3;%2;%1; % order of magnitude
[p, s] = polyfit(double(x), y, n);
y_fit = polyval(p, double(x_fit));

% 3 - way 3: least mean squares regression (elec = a * angle + b)
% try least mean squares regression
y_elec = [r_index_s3_90_elec, r_index_s3_120_elec, r_index_s3_150_elec, r_all_0_elec(4, :)];
x_angle = [r_index_s3_angle(1)*ones(size(r_index_s3_90_elec)), ...
           r_index_s3_angle(2)*ones(size(r_index_s3_120_elec)), ...
           r_index_s3_angle(3)*ones(size(r_index_s3_150_elec)), ...
           r_index_s3_angle(4)*ones(size(r_all_0_elec(4, :)))];
[pp, ss] = polyfit(x_angle, double(y_elec), 1); % elec = a * angle + b ==> angle = (elec - b) / a
a = pp(1); b = pp(2);
pp(1) = 1 / a; pp(2) = -b / a;
y_fit2 = polyval(pp, double(x_fit));


% plot the fitted result
figure;
p1 = plot(r_index_s3_90_elec, r_index_s3_angle(1)*ones(1, size(r_index_s3_90_elec ,2)), 'r.'); hold on; grid on;
plot(r_index_s3_120_elec, r_index_s3_angle(2)*ones(1, size(r_index_s3_120_elec, 2)), 'r.');
plot(r_index_s3_150_elec, r_index_s3_angle(3)*ones(1, size(r_index_s3_150_elec, 2)), 'r.');
plot(r_all_0_elec(4, :), r_index_s3_angle(4)*ones(1, size(r_all_0_elec(4, :), 2)), 'r.');

p2 = plot(r_index_s3_90_elec, r_index_s3_90_angle, 'b.'); hold on; grid on;
plot(r_index_s3_120_elec, r_index_s3_120_angle, 'b.');
plot(r_index_s3_150_elec, r_index_s3_150_angle, 'b.');
plot(r_all_0_elec(4, :), r_all_0_angle(4, :), 'b.');

p3 = plot(x_fit, y_fit, 'r-');
p4 = plot(x_fit, y_linear_fit, 'b-');
p5 = plot(x_fit, y_fit2, 'g-');

xlabel('Electrical signal', 'FontSize', 16); ylabel('Joint angle / degree', 'FontSize', 16);
title('Right Index S3 Joint');
legend([p1(1), p2(1), p3(1), p4(1), p5(1)], 'Ground Truth', 'Linearly Mapped Result', ...
                                     'Fitted Curve - Ground Truth', 'Fitted Curve - Linearly Mapped Result', 'Reversely linearly mapped', ...
                                     'Location', 'NorthEastOutside', 'FontSize', 14);

                                 
%% Load left index finger and display
% load angle and the corresponding electrical signal data
l_index_s3_90_angle = h5read(calib_file_name, '/l_index_s3_90/glove_angle'); 
l_index_s3_90_angle = l_index_s3_90_angle(4, :);
l_index_s3_90_elec = h5read(calib_file_name, '/l_index_s3_90/glove_elec');
l_index_s3_90_elec = l_index_s3_90_elec(4, :);

l_index_s3_120_angle = h5read(calib_file_name, '/l_index_s3_120/glove_angle'); 
l_index_s3_120_angle = l_index_s3_120_angle(4, :);
l_index_s3_120_elec = h5read(calib_file_name, '/l_index_s3_120/glove_elec');
l_index_s3_120_elec = l_index_s3_120_elec(4, :);

l_index_s3_150_angle = h5read(calib_file_name, '/l_index_s3_150/glove_angle'); 
l_index_s3_150_angle = l_index_s3_150_angle(4, :);
l_index_s3_150_elec = h5read(calib_file_name, '/l_index_s3_150/glove_elec');
l_index_s3_150_elec = l_index_s3_150_elec(4, :);

% post-processing, clamp the values to be inside range
l_index_s3_90_elec_clamped = max(min(l_index_s3_90_elec, l_elec_max(4)), l_elec_min(4));
l_index_s3_120_elec_clamped = max(min(l_index_s3_120_elec, l_elec_max(4)), l_elec_min(4));
l_index_s3_150_elec_clamped = max(min(l_index_s3_150_elec, l_elec_max(4)), l_elec_min(4));

% diplay angle and the corresponding electrical signal   
%{
figure;
plot(1:size(l_index_s3_90_angle, 2), l_index_s3_90_angle(2, :), 'b-'); hold on; grid on;
plot(1:size(l_index_s3_90_elec, 2), l_index_s3_90_elec(2, :), 'r-'); hold on; grid on;
%}

% debug: try linear mapping using only two end-points as is applied by WiseGlove SDK   
%{
l_index_s3_90_angle_mapped_from_elec = lineal_map(l_index_s3_90_elec, l_elec_min(2), l_elec_max(2), l_angle_min(2), l_angle_max(2));
figure;
plot(1:size(l_index_s3_90_angle, 2), l_index_s3_90_angle, 'b-.', 'LineWidth', 3); hold on; grid on;
plot(1:size(l_index_s3_90_angle_mapped_from_elec, 2), l_index_s3_90_angle_mapped_from_elec, 'r--', 'LineWidth', 3);
%}

% display the relation between electrical signal and 
l_index_s3_angle = 180 - [90, 120, 150, 180]; 
% l_index_s3_elec = [median(l_index_s3_90_elec_clamped), median(l_index_s3_120_elec_clamped), median(l_index_s3_150_elec_clamped)];



figure;
p1 = plot(l_index_s3_90_elec, l_index_s3_angle(1)*ones(1, size(l_index_s3_90_elec ,2)), 'r.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_angle(2)*ones(1, size(l_index_s3_120_elec, 2)), 'r.');
plot(l_index_s3_150_elec, l_index_s3_angle(3)*ones(1, size(l_index_s3_150_elec, 2)), 'r.');
plot(l_all_0_elec(4, :), l_index_s3_angle(4)*ones(1, size(l_all_0_elec(4, :), 2)), 'r.');

p2 = plot(l_index_s3_90_elec, l_index_s3_90_angle, 'b.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_120_angle, 'b.');
plot(l_index_s3_150_elec, l_index_s3_150_angle, 'b.');
plot(l_all_0_elec(4, :), l_all_0_angle(4, :), 'b.');
xlabel('Electrical signal'); ylabel('Joint angle / degree');
title('Left Index S3 Joint');
legend([p1(1), p2(1)], 'Ground Truth', 'Linearly Mapped Result', 'Location', 'NorthEastOutside');


% fit a curve to the data
% prepare data
x = [mean(l_index_s3_90_elec), ...
     mean(l_index_s3_120_elec), ...
     mean(l_index_s3_150_elec), ...
     mean(l_all_0_elec(4, :))];
y = [l_index_s3_angle(1), ... %*ones(1, size(l_index_s3_90_elec ,2)), ...
     l_index_s3_angle(2), ... %*ones(1, size(l_index_s3_120_elec ,2)), ...
     l_index_s3_angle(3), ... %*ones(1, size(l_index_s3_150_elec ,2)), ...
     l_index_s3_angle(4)]; %*ones(1, size(l_all_0_elec(4, :) ,2))];
x_linear = [l_index_s3_90_elec, ...
            l_index_s3_120_elec, ...
            l_index_s3_150_elec, ...
            l_all_0_elec(4, :)];
[x_linear, IA, IC] = unique(x_linear);
y_linear = [l_index_s3_90_angle, ...
            l_index_s3_120_angle, ...
            l_index_s3_150_angle, ...
            l_all_0_angle(4, :)];
y_linear = y_linear(IA); % remove duplicate points?        
x_fit = min([l_elec_min(4), x, x_linear]) : 10 : max([l_elec_max(4), x, x_linear]);
% perform linear interpolation for the linearly mapped data points 
% (no need to do extra fitting since the angle data is a linearly interpolated result. 
% All we need is to see its whole landscape.)
y_linear_fit = interp1(double(x_linear), y_linear, double(x_fit), 'linear');

% 1 - way 1: spline fitting (doesn't allow duplicate values for the first input)
% y_fit = spline(double(x), double(y), double(x_fit));

% 2 - way 2: polynomial fitting (allows duplicate values for x)
n = 4;%3;%1; % order of magnitude
[p, s] = polyfit(double(x), y, n);
y_fit = polyval(p, double(x_fit));


% 3 - way 3: least mean squares regression (elec = a * angle + b)
% try least mean squares regression
y_elec = [l_index_s3_90_elec, l_index_s3_120_elec, l_index_s3_150_elec, l_all_0_elec(4, :)];
x_angle = [l_index_s3_angle(1)*ones(size(l_index_s3_90_elec)), ...
           l_index_s3_angle(2)*ones(size(l_index_s3_120_elec)), ...
           l_index_s3_angle(3)*ones(size(l_index_s3_150_elec)), ...
           l_index_s3_angle(4)*ones(size(l_all_0_elec(4, :)))];
[pp, ss] = polyfit(x_angle, double(y_elec), 1); % elec = a * angle + b ==> angle = (elec - b) / a
a = pp(1); b = pp(2);
pp(1) = 1 / a; pp(2) = -b / a;
y_fit2 = polyval(pp, double(x_fit));


% 3 - way 3: piecewise cubic Hermite interpolating polynomial, i.e. pchip
% y_fit = pchip(double(x), double(y), double(x_fit));

% 4 - interp1
% y_fit = interp1(double(x), double(y), double(x_fit), 'makima'); %'previous'); %'next'); %'nearest'); %'pchip'); %'cubic'); %'spline'); %'linear');

% plot the fitted result
figure;
p1 = plot(l_index_s3_90_elec, l_index_s3_angle(1)*ones(1, size(l_index_s3_90_elec ,2)), 'r.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_angle(2)*ones(1, size(l_index_s3_120_elec, 2)), 'r.');
plot(l_index_s3_150_elec, l_index_s3_angle(3)*ones(1, size(l_index_s3_150_elec, 2)), 'r.');
plot(l_all_0_elec(4, :), l_index_s3_angle(4)*ones(1, size(l_all_0_elec(4, :), 2)), 'r.');

p2 = plot(l_index_s3_90_elec, l_index_s3_90_angle, 'b.'); hold on; grid on;
plot(l_index_s3_120_elec, l_index_s3_120_angle, 'b.');
plot(l_index_s3_150_elec, l_index_s3_150_angle, 'b.');
plot(l_all_0_elec(4, :), l_all_0_angle(4, :), 'b.');

p3 = plot(x_fit, y_fit, 'r-');
p4 = plot(x_fit, y_linear_fit, 'b-');
p5 = plot(x_fit, y_fit2, 'g-');

xlabel('Electrical signal', 'FontSize', 16); ylabel('Joint angle / degree', 'FontSize', 16);
title('Left Index S3 Joint');
legend([p1(1), p2(1), p3(1), p4(1), p5(1)], 'Ground Truth', 'Linearly Mapped Result', ...
                                     'Fitted Curve - Ground Truth', 'Fitted Curve - Linearly Mapped Result', 'Reversely linearly mapped', ...
                                     'Location', 'NorthEastOutside', 'FontSize', 14);


                                 
%% Calibrate index S3 joint data according to calibration data       
%{
% load test sequence data
% l_test_seq_1_angle = h5read(calib_file_name, '/l_test_seq_1/glove_angle');
% l_test_seq_1_elec = h5read(calib_file_name, '/l_test_seq_1/glove_elec');
% r_test_seq_1_angle = h5read(calib_file_name, '/r_test_seq_1/glove_angle');
% r_test_seq_1_elec = h5read(calib_file_name, '/r_test_seq_1/glove_elec');

test_seq_1_angle = h5read(calib_file_name, '/test_finger_1/glove_angle');
test_seq_1_elec = h5read(calib_file_name, '/test_finger_1/glove_elec');
l_test_seq_1_angle = test_seq_1_angle(1:15, :);
l_test_seq_1_elec = test_seq_1_elec(1:15, :);
r_test_seq_1_angle = test_seq_1_angle(16:end, :);
r_test_seq_1_elec = test_seq_1_elec(16:end, :);


% get raw index s3 joint data
l_test_seq_1_index_s3_angle = l_test_seq_1_angle(4, :);
l_test_seq_1_index_s3_elec = l_test_seq_1_elec(4, :);
% l_test_seq_1_index_s3_elec_clamped = max(min(l_test_seq_1_index_s3_elec, l_elec_max(4)), l_elec_min(4));

r_test_seq_1_index_s3_angle = r_test_seq_1_angle(4, :);
r_test_seq_1_index_s3_elec = r_test_seq_1_elec(4, :);
% r_test_seq_1_index_s3_elec_clamped = max(min(r_test_seq_1_index_s3_elec, r_elec_max(4)), r_elec_min(4));

% get calibration data
x_l_index_s3 = [mean(l_index_s3_90_elec), ...
     mean(l_index_s3_120_elec), ...
     mean(l_index_s3_150_elec), ...
     mean(l_all_0_elec(4, :))];
y_l_index_s3 = [l_index_s3_angle(1), ...%*ones(1, size(l_index_s3_90_elec ,2)), ...
     l_index_s3_angle(2), ...%*ones(1, size(l_index_s3_120_elec ,2)), ...
     l_index_s3_angle(3), ...%*ones(1, size(l_index_s3_150_elec ,2)), ...
     l_index_s3_angle(4)]; %*ones(1, size(l_all_0_elec(4, :) ,2))];
x_r_index_s3 = [mean(r_index_s3_90_elec), ...
     mean(r_index_s3_120_elec), ...
     mean(r_index_s3_150_elec), ...
     mean(r_all_0_elec(4, :))];
y_r_index_s3 = [r_index_s3_angle(1), ...%*ones(1, size(r_index_s3_90_elec ,2)), ...
     r_index_s3_angle(2), ...%*ones(1, size(r_index_s3_120_elec ,2)), ...
     r_index_s3_angle(3), ...%*ones(1, size(r_index_s3_150_elec ,2)), ...
     r_index_s3_angle(4)];%*ones(1, size(r_all_0_elec(4, :) ,2))];

 
[l_test_seq_1_index_s3_angle_calibrated, r_test_seq_1_index_s3_angle_calibrated] = ...
calib_finger(y_l_index_s3, x_l_index_s3, l_test_seq_1_index_s3_angle, l_test_seq_1_index_s3_elec, ...
             y_r_index_s3, x_r_index_s3, r_test_seq_1_index_s3_angle, r_test_seq_1_index_s3_elec, ...
             true);
%}

         

%% Calibrate all flexion/extension joints of three fingers
%prep
finger_name = {'index', 'middle', 'ring'};
joint_id = [[3, 4]; ...
            [6, 7]; ...
            [9, 10]];  % starts from 0
d_right = 15; % offset from left joints to right corresponding joints

% read an example data for calibration
test_seq_name = 'kaoqin_new'; %'test_finger_1'; %'gun_new'; %'test_finger_2'; %'test_finger_1';
test_seq_angle = h5read(calib_file_name, ['/', test_seq_name, '/glove_angle']);
test_seq_elec = h5read(calib_file_name, ['/', test_seq_name, '/glove_elec']);
test_seq_angle_calib = test_seq_angle; % for storing the calibrated data


% 1 - iterate over flexion/extension for four fingers
for fid = 1 : 3
    for jid = 1 : 2
        %% get ID
        l_id = joint_id(fid, jid) + 1; % starts from 1, used to access array in MATLAB
        r_id = l_id + d_right;
        
        %% read calib data
        % l
        l_90_angle = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_90/glove_angle']);
        l_90_angle = l_90_angle(l_id, :);
        l_90_elec = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_90/glove_elec']);
        l_90_elec = l_90_elec(l_id, :);
        
        l_120_angle = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_120/glove_angle']);                
        l_120_angle = l_120_angle(l_id, :);
        l_120_elec = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_120/glove_elec']);
        l_120_elec = l_120_elec(l_id, :);
        
        l_150_angle = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_150/glove_angle']);
        l_150_angle = l_150_angle(l_id, :);
        l_150_elec = h5read(calib_file_name, ['/l_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_150/glove_elec']);
        l_150_elec = l_150_elec(l_id, :);
        
        % r
        r_90_angle = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_90/glove_angle']);
        r_90_angle = r_90_angle(r_id, :);
        r_90_elec = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_90/glove_elec']);
        r_90_elec = r_90_elec(r_id, :);
        
        r_120_angle = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_120/glove_angle']);                
        r_120_angle = r_120_angle(r_id, :);
        r_120_elec = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_120/glove_elec']);
        r_120_elec = r_120_elec(r_id, :);
        
        r_150_angle = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_150/glove_angle']);
        r_150_angle = r_150_angle(r_id, :);
        r_150_elec = h5read(calib_file_name, ['/r_', finger_name{fid}, '_s', num2str(joint_id(fid, jid)), '_150/glove_elec']);
        r_150_elec = r_150_elec(r_id, :);
        
        % set paired data 
        % 1 - use mean data only
%         l_elec = [mean(l_90_elec), ...
%             mean(l_120_elec), ...
%             mean(l_150_elec), ...
%             mean(l_all_0_elec(l_id, :))];
%         l_angle = 180 - [90, 120, 150, 180]; 
%         r_elec = [mean(r_90_elec), ...
%             mean(r_120_elec), ...
%             mean(r_150_elec), ...
%             mean(r_all_0_elec(l_id, :))];
%         r_angle = 180 - [90, 120, 150, 180]; 
        % 2 - use all data
        l_elec = [l_90_elec, l_120_elec, l_150_elec, l_all_0_elec(l_id, :)];
        l_angle = [90 * ones(size(l_90_elec)), ...
                   60 * ones(size(l_120_elec)), ...
                   30 * ones(size(l_150_elec)), ...
                   0 * ones(size(l_all_0_elec(l_id, :)))];
        r_elec = [r_90_elec, r_120_elec, r_150_elec, r_all_0_elec(l_id, :)];
        r_angle = [90 * ones(size(r_90_elec)), ...
                   60 * ones(size(r_120_elec)), ...
                   30 * ones(size(r_150_elec)), ...
                   0 * ones(size(r_all_0_elec(l_id, :)))];       
        
        % get data for calibration 
        l_calib_angle = test_seq_angle(l_id, :);
        l_calib_elec = test_seq_elec(l_id, :);
        r_calib_angle = test_seq_angle(r_id, :);
        r_calib_elec = test_seq_elec(r_id, :);        
        
        % pre-processing, clampping on elec data
%         l_elec = max(min(l_elec, l_elec_max(l_id)), l_elec_min(l_id));
%         r_elec = max(min(r_elec, r_elec_max(l_id)), r_elec_min(l_id));
        
        
        % call helper function to calibrate test data
        finger_flag = ['S', num2str(joint_id(fid, jid))];
        [new_angle_calib_l, new_angle_calib_r] = calib_finger(l_angle, l_elec, l_calib_angle, l_calib_elec, ...
                                                              r_angle, r_elec, r_calib_angle, r_calib_elec, ...
                                                              l_angle_min(l_id), l_angle_max(l_id), ...
                                                              r_angle_min(l_id), r_angle_max(l_id), ..., 
                                                              false, finger_flag);
        
        % post-processing, clampping on angle data
%         new_angle_calib_l = max(min(new_angle_calib_l, l_angle_max(l_id)), l_angle_min(l_id));
%         new_angle_calib_r = max(min(new_angle_calib_r, r_angle_max(l_id)), r_angle_min(l_id)); % use l_id for r_elec_min too
                                                          
        % store the calibrated data
        test_seq_angle_calib(l_id, :) = new_angle_calib_l;
        test_seq_angle_calib(r_id, :) = new_angle_calib_r;
                                                  
    end
    
end

% 2 - iterate over abduction/adduction for all five fingers
% S2 (thumb-index)

% S5 (index-middle)

% S8 (middle-ring)

% S11 (ring-little)



% 3 - thumb angles
% S14
thumb_s14_0_elec = h5read(calib_file_name, ['/lr_thumb_s14_0/glove_elec']);
l_thumb_s14_0_elec = thumb_s14_0_elec(15, :);
r_thumb_s14_0_elec = thumb_s14_0_elec(15+d_right, :);

thumb_s14_90_elec = h5read(calib_file_name, ['/lr_thumb_s14_90/glove_elec']);
l_thumb_s14_90_elec = thumb_s14_90_elec(15, :);
r_thumb_s14_90_elec = thumb_s14_90_elec(15+d_right, :);

% prepare data to aid calibration
l_elec = [l_thumb_s14_0_elec, l_thumb_s14_90_elec];
l_angle = [0 * ones(size(l_thumb_s14_0_elec)), 90 * ones(size(l_thumb_s14_90_elec))];
r_elec = [r_thumb_s14_0_elec, r_thumb_s14_90_elec];
r_angle = [0 * ones(size(r_thumb_s14_0_elec)), 90 * ones(size(r_thumb_s14_90_elec))];

% get data for calibration 
l_calib_angle = test_seq_angle(15, :);
l_calib_elec = test_seq_elec(15, :);
r_calib_angle = test_seq_angle(15+d_right, :);
r_calib_elec = test_seq_elec(15+d_right, :);  

% calibrate
finger_flag = 'S14';
[new_angle_calib_l, new_angle_calib_r] = calib_finger(l_angle, l_elec, l_calib_angle, l_calib_elec, ...
                                                      r_angle, r_elec, r_calib_angle, r_calib_elec, ...
                                                      l_angle_min(15), l_angle_max(15), ...
                                                      r_angle_min(15), r_angle_max(15), ..., 
                                                      false, finger_flag);

% save the calibrated result
test_seq_angle_calib(15, :) = new_angle_calib_l;
test_seq_angle_calib(15+d_right, :) = new_angle_calib_r;


% S0


% S1



%% save the calibrated results
%
h5create(calib_file_name, ['/', test_seq_name, '_calibrated'], size(test_seq_angle_calib));
h5write(calib_file_name, ['/', test_seq_name, '_calibrated'], test_seq_angle_calib);
%}

